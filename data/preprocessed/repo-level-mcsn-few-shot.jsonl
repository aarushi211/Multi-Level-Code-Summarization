{"repo_name": "apache/airflow", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Checks if a task is either queued or running in this executor\n\none method to fetch connection params as a dict used in get_uri() and get_connection()\n\noverride DbApiHook get_uri method for get_sqlalchemy_engine()\n\nreturns aws_access_key_id, aws_secret_access_key from extra intended to be used by external import and export statements\n\nExecutes SQL using psycopg2 copy_expert method. Necessary to execute COPY command without access to a superuser.\n\nLoads a tab-delimited file into a database table\n\nDumps a database table into a tab-delimited file\n\nUploads the file to Google cloud storage\n\nGets the max partition for a table.\n\nThis function finds the date in a list closest to the target date. An optional parameter can be given to get the closest before or after."}
{"repo_name": "tensorflow/probability", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Embeds a custom gradient into a `Tensor`. This function works by clever application of `stop_gradient`. I.e., observe\n\nComputes `f(*xs)` and its gradients wrt to `*xs`.\n\nConvenience function to efficiently construct a MultivariateNormalDiag.\n\nEight-schools joint log-prob.\n\nRuns HMC on the eight-schools unnormalized posterior.\n\nDecorator to programmatically expand the docstring.\n\nInfer the original name passed into a distribution constructor. Distributions typically follow the pattern of with.name_scope(name) as\n\nRandomVariable constructor with a dummy name argument.\n\nFactory function to make random variable given distribution class.\n\nShape for the mode/mean Tensors."}
{"repo_name": "intel-analytics/BigDL", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Add a learning rate scheduler to the contained `schedules`\n\nsave OptimMethod\n\nConfigure checkpoint settings.\n\nConfigure constant clipping settings.\n\nDo an optimization.\n\nCreate an optimizer. Depend on the input type, the returning optimizer can be a local optimizer \\ or a distributed optimizer.\n\nConfigure validation settings.\n\nSet new training dataset, for optimizer reuse\n\nConfigure validation settings.\n\nSet the interval of recording for each indicator."}
{"repo_name": "deepmipt/DeepPavlov", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Expand and tile tensor along given axis\n\nCompute additive self attention for time series of vectors (with batch dimension) the\n\nCompute multiplicative self attention for time series of vectors (with batch dimension) the\n\nCollecting possible continuations of length <= n for every node\n\n\u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u0442 \u0434\u0435\u0440\u0435\u0432\u043e \u0434\u043b\u044f \u0434\u0430\u043b\u044c\u043d\u0435\u0439\u0448\u0435\u0433\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f\n\n\u0412\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u043a\u044d\u0448\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u043a descend\n\n\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 s \u0432 \u043f\u0440\u0435\u0444\u0438\u043a\u0441\u043d\u044b\u0439 \u0431\u043e\u0440\n\n\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0438\u0442\u0435\u0440\u0430\u0442\u043e\u0440 \u043f\u043e \u0441\u043b\u043e\u0432\u0430\u043c, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u043c\u0441\u044f \u0432 \u0431\u043e\u0440\u0435\n\n\u041d\u0430\u0445\u043e\u0434\u0438\u0442 \u0432\u0441\u0435 \u0440\u0430\u0437\u0431\u0438\u0435\u043d\u0438\u044f s = s_1\n\n\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0440\u0435\u0431\u0451\u043d\u043a\u0430 \u043a \u0432\u0435\u0440\u0448\u0438\u043d\u0435 parent \u043f\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u0443 \u0441 \u043a\u043e\u0434\u043e\u043c code"}
{"repo_name": "h2oai/h2o-3", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Creates new Generic model by loading existing embedded model into library, e.g. from H2O MOJO. The imported model must be supported by H2O.\n\nExtract full regularization path explored during lambda search from glm model.\n\nCreate a custom GLM model using the given coefficients. Needs to be passed source model trained on the dataset to extract the dataset information from.\n\nCreate H2OCluster object from a list of key-value pairs.\n\nShut down the server. This method checks if the H2O cluster is still running, and if it does shuts it down (via a REST API call).\n\nDetermine if the H2O cluster is running or not.\n\nPrint current cluster status information.\n\nList all jobs performed by the cluster.\n\nReturn the list of all known timezones.\n\nUpdate information in this object from another H2OCluster instance."}
{"repo_name": "Azure/azure-sdk-for-python", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Add a specific enqueue time to the message.\n\nGives the sas-url to download the configurations for vpn-sites in a resource group.\n\nModule depends on the API\n\nInstance depends on the API\n\nInstance depends on the API\n\nInstance depends on the API\n\nInstance depends on the API\n\nInstance depends on the API\n\nInstance depends on the API\n\nInstance depends on the API"}
{"repo_name": "streamlink/streamlink", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Attempts to extract available streams.\n\nStore the cookies from ``http`` in the plugin cache until they expire. The cookies can be filtered by supplying a filter method. eg. ``lambda\n\nLoad any stored cookies for the plugin that have not expired.\n\nRemoves all of the saved cookies for this Plugin. To filter the cookies that are deleted specify the ``cookie_filter`` argument (see :func:`save_cookies`).\n\nReturn a shell-escaped version of the string *s*. Backported from Python 3.3 standard library module shlex.\n\nDrops Characters by unicode not by bytes.\n\nClears out the previous line and prints a new one.\n\nFormats the file size into a human readable format.\n\nFormats elapsed seconds into a human readable format.\n\nCreates a status line with appropriate size."}
{"repo_name": "vaexio/vaex", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Similar to monochrome, but now do it for multiple colors\n\nFunction decorater that executes the function in parallel\n\nImplementation of Dataset.to_arrow_table\n\nAdds method f to the Dataset class\n\nAdd ecliptic coordates (long_out, lat_out) from equatorial coordinates.\n\nConvert parallax to distance (i.e. 1/parallax)\n\nConcert velocities from a cartesian system to proper motions and radial velocities\n\nTransform/rotate proper motions from equatorial to galactic coordinates Taken from\n\nTransform/rotate proper motions from galactic to equatorial coordinates. Inverse of :py:`add_virtual_columns_proper_motion_eq2gal`\n\nConvert radial velocity and galactic proper motions (and positions) to cartesian velocities wrt the center_v Based on"}
{"repo_name": "librosa/librosa", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Return the version information for all librosa dependencies.\n\nHandle renamed arguments.\n\nSet the FFT library used by librosa.\n\nBeat tracking function\n\nLoad audio, estimate tuning, apply pitch correction, and save.\n\nConverts frame indices to audio sample indices.\n\nConverts sample indices into STFT frames.\n\nConverts frame counts to time (seconds).\n\nConverts time stamps into STFT frames.\n\nConvert one or more MIDI numbers to note strings. MIDI numbers will be rounded to the nearest integer. Notes will be of the format 'C0', 'C#0', 'D0',"}
{"repo_name": "open-mmlab/mmcv", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Read the frame images from a directory and join them as a video\n\nRead the next frame. If the next frame have been decoded before and in the cache, then return it directly, otherwise decode, cache and return it.\n\nGet frame by index.\n\nConvert a video to frame images\n\nTrack the progress of tasks execution with a progress bar. Tasks are done with a simple for-loop.\n\nFlip an image horizontally or vertically.\n\nRotate an image.\n\nClip bboxes to fit the image shape.\n\nScaling bboxes w.r.t the box center.\n\nCrop image patches. 3"}
{"repo_name": "Microsoft/botbuilder-python", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Helper method that compares two StoreItems and their e_tags and returns True if the new_value should overwrite the old_value. Otherwise returns False.\n\nCalled by the parent class to run the adapters middleware set and calls the passed in `callback()` handler at the end of the chain.\n\nRegisters middleware plugin(s) with the bot or set.\n\nSend information about the page viewed in the application (a web page for instance).\n\nSend information about a single exception that occurred in the application.\n\nSend information about a single event that has occurred in the context of the application.\n\nSend information about a single metric data point that was captured for the application.\n\nSends a single trace statement.\n\nSends a single request that was captured for the application.\n\nSends a single dependency telemetry that was captured for the application."}
{"repo_name": "Qiskit/qiskit-terra", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "return instruction params\n\nAssemble a QasmQobjInstruction\n\nFor a composite instruction, reverse the order of sub-gates. This is done by recursively mirroring all sub-instructions. It does not invert any gate.\n\nAdd classical control on register classical and value val.\n\nshallow copy of the instruction.\n\nPrint an if statement if needed.\n\nReturn a default OpenQASM string for the instruction. Derived instructions may override this to print in a different format (e.g. measure q[0] -> c[0];).\n\nSet the options of each passset, based on precedence\n\nRun all the passes on a QuantumCircuit\n\nDo a pass and its \"requires\"."}
{"repo_name": "yandex/yandex-tank", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "return load plan (timestamps generator)\n\nreturn ammo generator\n\ntranslate http code to net code. if accertion failed, set net code to 314\n\ntranslate exception str to http code\n\nRead phantom tool specific options\n\nGenerate phantom tool run config\n\nget merged info about phantom conf\n\nreads config\n\ncompose benchmark block\n\ndownload remote resources, replace links with local filenames add result file section"}
{"repo_name": "dagster-io/dagster", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Create a new ``MultipleResults`` object from a dictionary. Keys of the dictionary are unpacked into result names.\n\ngunzips /path/to/foo.gz to /path/to/raw/2019/01/01/data.json\n\nEnsures argument obj is a dictionary, and enforces that the keys/values conform to the types specified by key_type, value_type.\n\nEnsures argument obj is a native Python dictionary, raises an exception if not, and otherwise returns obj.\n\nEnsures argument obj is either a dictionary or None; if the latter, instantiates an empty dictionary.\n\nCallback receives a stream of event_records\n\nRecord a stream of event records to json\n\nAssigned parameters into the appropiate place in the input notebook\n\nCreates a solid with the given number of (meaningless) inputs and outputs. Config controls the behavior of the nonce solid.\n\nThis recursive descent thing formats a config dict for GraphQL."}
{"repo_name": "SectorLabs/django-postgres-extra", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Updates all rows that match the filter.\n\nSets the action to take when conflicts arise when attempting to insert/create a new row.\n\nCreates multiple new records in the database. This allows specifying custom conflict behavior using .on_conflict(). If no special behavior was specified, this uses the normal Django create(\n\nCreates a new record in the database. This allows specifying custom conflict behavior using .on_conflict(). If no special behavior was specified, this uses the normal Django create(\n\nCreates a new record or updates the existing one with the specified data.\n\nCreates a new record or updates the existing one with the specified data and then gets the row.\n\nCreates a set of new records or updates the existing ones with the specified data.\n\nBuilds the SQL compiler for a insert query.\n\nVerifies whether this field is gonna modify something on its own. \"Magical\" means that a field modifies the field value during the pre_save.\n\nSets the action to take when conflicts arise when attempting to insert/create a new row."}
{"repo_name": "chaoss/grimoirelab-perceval", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Fetch the messages.\n\nInit client\n\nParse posts and returns in order.\n\nFetch the history of a channel.\n\nFetch user data.\n\nFetch a resource.\n\nInitialize mailing lists directory path\n\nGet the mboxes managed by this mailing list.\n\nFetch the entries from the url. The method retrieves all entries from a RSS url\n\nFetch the entries"}
{"repo_name": "celiao/tmdbsimple", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Get the list of Movie genres.\n\nGet the list of TV genres.\n\nGet the list of movies for a particular genre by id. By default, only movies with 10 or more votes are included.\n\nGet the basic movie information for a specific movie id.\n\nGet the alternative titles for a specific movie id.\n\nGet the cast and crew information for a specific movie id.\n\nGet the external ids for a specific movie id.\n\nGet the images (posters and backdrops) for a specific movie id.\n\nGet the plot keywords for a specific movie id.\n\nGet a list of recommended movies for a movie."}
{"repo_name": "bloomreach/s4cmd", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Decorator to log function calls.\n\nDecorator to synchronize function.\n\nShow current progress message to stderr. This function will remember the previous message so that next time, it will clear the previous message before showing next one.\n\nProgram message output.\n\nUtility function to handle runtime failures gracefully. Show concise information if possible, then terminate program.\n\nGet a temp filename for atomic download.\n\nAtomically rename and clean tempfile\n\nClean up temp files\n\nReturn a list of the logger\n\nGet the fixed part of the path without wildcard"}
{"repo_name": "PyCQA/pylint", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Return true if given node is inside lambda\n\nRecursively returns all atoms in nested lists and tuples.\n\nChecks if an assignment node in an except handler clobbers an existing variable.\n\nreturn True if the node is referencing the \"super\" builtin function\n\nreturn true if the function does nothing but raising an exception\n\nreturn true if the given Name node is used in function or lambda default argument's value\n\nreturn true if the name is used in function decorator\n\nreturn True if `frame` is an astroid.Class node with `node` in the subtree of its bases attribute\n\nreturn the higher parent which is not an AssignName, Tuple or List node\n\nreturn True if <name> is a method overridden from an ancestor"}
{"repo_name": "lepture/flask-oauthlib", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Configures an :class:`OAuth2Provider` instance to use various caching systems to get and set the grant token. This removes the need to register :func:`grantgetter` and :func:`grantsetter` yourself.\n\nConfigures the given :class:`OAuth2Provider` instance with the required getters and setters for persistence with SQLAlchemy. An example of using all\n\nRemoves itself from the cache\n\nDetermines which method of getting the query object for use\n\nreturns a Token object with the given access token or refresh token\n\nCreates a Token object and removes all expired tokens that belong to the user\n\nCreates Grant object with the given params\n\nGet the Grant object with the given client ID and code\n\nParse the response returned by :meth:`OAuthRemoteApp.http_request`.\n\nMake request parameters right."}
{"repo_name": "pyca/pyopenssl", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Call the method repeatedly such that it will raise an exception.\n\nCall the method repeatedly such that it will return a PKey object.\n\nCall the function with an encrypted PEM and a passphrase callback.\n\nCall the function with an encrypted PEM and a passphrase callback which returns the wrong passphrase.\n\nCall the function with an encrypted PEM and a passphrase callback which returns a non-string.\n\nCreate a CRL object with 100 Revoked objects, then call the get_revoked method repeatedly.\n\nCopy an empty Revoked object repeatedly. The copy is not garbage collected, therefore it needs to be manually freed.\n\nRepeatedly create an EC_KEY\n\nConnect to an SNI-enabled server and request a specific hostname, specified by argv[1], of it.\n\nCreate a public/private key pair."}
{"repo_name": "zqfang/GSEApy", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "calculate pvalues for all categories in the graph\n\nbenjamini hocheberg fdr correction. inspired by statsmodels\n\nStandardize the mean and variance of the data axis\n\nVisualize the dataframe.\n\nThis is the main function for reproducing the gsea plot.\n\nVisualize enrichr results.\n\nVisualize enrichr results.\n\nfunction for removing spines and ticks.\n\nThe Main function/pipeline for GSEApy.\n\nPrepare argparser object. New options will be added in this function first."}
{"repo_name": "3DLIRIOUS/MeshLabXML", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Create a cube primitive Note that this is made of 6 quads, not triangles\n\nCreate a torus mesh\n\nCreates a square open tube, e.g. a box with no top or bottom. Useful if you want to wrap it around and join the open ends together, forming a torus.\n\nCreates a square open tube, e.g. a box with no top or bottom. Useful if you want to wrap it around and join the open ends together, forming a torus.\n\nCreates a plane with a specified number of vertices on it sides, but no vertices on the interior. Currently used to create a simpler bottom for cube_hires.\n\nCreate a cylinder with user defined number of segments\n\nCreate a cylinder with user defined number of segments\n\nRead color_names.txt and find the red, green, and blue values for a named color.\n\nCheck if a variable is a list and is the correct length. If variable is not a list it will make it a list of the correct length with all terms identical.\n\nMake a variable a list if it is not already If variable is not a list it will make it a list of the correct length with all terms identical."}
{"repo_name": "neurosynth/neurosynth", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Decodes a set of images.\n\nLoad features from current Dataset instance or a list of files.\n\nLoad feature data from a 2D ndarray on disk.\n\nLoad feature image data from the current Dataset instance. See load_features() for documentation.\n\nLoad feature image data from image files.\n\nDecode images using Pearson's r. Computes the correlation between each input image and each feature image across voxels.\n\nDecoding using the dot product.\n\nImplements various kinds of feature selection\n\nWrapper for scikit-learn classification functions Imlements various types of classification and cross validation\n\nFits X to outcomes y, using clf"}
{"repo_name": "mental32/spotify.py", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Get the application bearer token from client_id and client_secret.\n\nMake a request to the spotify API with the current bearer credentials.\n\nGet a spotify album by its ID.\n\nGet an albums tracks by an ID.\n\nGet a spotify album by its ID.\n\nGet a spotify artist by their ID.\n\nGet an artists tracks by their ID.\n\nGet an artists top tracks per country with their ID.\n\nGet related artists for an artist by their ID.\n\nGet a spotify artists by their IDs."}
{"repo_name": "funilrys/PyFunceble", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Execute the logic behind the meaning of ExpirationDate + return the matched status.\n\nConvert a given month into our unified format.\n\nA little internal helper of self.format. (Avoiding of nested loops)\n\nFormat the expiration date into an unified format (01-jan-1970).\n\nExtract the expiration date from the whois record.\n\nRead the code and update all links.\n\nCheck if the current version is greater as the older older one.\n\nCheck if the current branch is `dev`.\n\nCheck if we have to put the previous version into the deprecated list.\n\nUpdate the given documentation file or :code:`README.rst` so that it always gives branch related URL and informations."}
{"repo_name": "OpenKMIP/PyKMIP", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Read the data encoding the ObtainLease response payload and decode it into its constituent parts.\n\nWrite the data encoding the ObtainLease response payload to a stream.\n\nWrite the data encoding the Cancel request payload to a stream.\n\nRead the data encoding the Cancel response payload and decode it into its constituent parts.\n\nRead the data encoding the Digest object and decode it into its constituent parts.\n\nWrite the data encoding the Digest object to a stream.\n\nConstruct a Digest object from provided digest values.\n\nRead the data encoding the ApplicationSpecificInformation object and decode it into its constituent parts.\n\nWrite the data encoding the ApplicationSpecificInformation object to a stream.\n\nConstruct an ApplicationSpecificInformation object from provided data and namespace values."}
{"repo_name": "iotaledger/iota.lib.py", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Generates the correct checksum for this address.\n\nExecutes the command and (optionally) returns an exit code (used by the shell to determine if the application exited cleanly).\n\nExecutes the command from a collection of arguments (e.g., :py:data`sys.argv`) and returns the exit code.\n\nParses arguments for the command.\n\nPrompts the user to enter their seed via stdin.\n\nGenerates a single key.\n\nGenerates the key associated with the specified address. Note that this method will generate the wrong key if the input address was generated from a different key!\n\nCreates a generator that can be used to progressively generate new keys.\n\nPrepares the hash sponge for the generator.\n\nAbsorb trits into the sponge."}
{"repo_name": "agile-geoscience/striplog", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Load a lexicon from a JSON file.\n\nGiven a string and a category, finds and combines words into groups based on their proximity.\n\nGiven a string and a dict of synonyms, returns the 'preferred' word. Case insensitive.\n\nParse a piece of text and replace any abbreviations with their full word equivalents. Uses the lexicon.abbreviations dictionary to find abbreviations.\n\nTakes a piece of text representing a lithologic description for one component, e.g. \"Red vf-f sandstone\" and turns it into a dictionary of attributes.\n\nSplit a description into parts, each of which can be turned into a single component.\n\nLists the categories in the lexicon, except the optional categories.\n\nJupyter Notebook magic repr function.\n\nJupyter Notebook magic repr function as a row \u2013 used by ``Legend._repr_html_()``.\n\nMake a simple plot of the Decor."}
{"repo_name": "quantopian/pgcontents", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Clear all matching our user_id.\n\nGuess the type of a file. If allow_directory is False, don't consider the possibility that the file is a directory.\n\nGet the id of a file in the database. This function is specific to this implementation of ContentsManager and is not in the base class.\n\nGet a notebook from the database.\n\nBuild a notebook model from database record.\n\nGet a directory from the database.\n\nApply _notebook_model_from_db or _file_model_from_db to each entry in file_records, depending on the result of `guess_type`.\n\nBuild a directory model from database directory record.\n\nBuild a file model from database record.\n\nSave a notebook."}
{"repo_name": "CiscoDevNet/webexteamssdk", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Add someone to a team by Person ID or email address. Add someone to a team by Person ID or email address; optionally making them a moderator.\n\nUpdate a team membership, by ID.\n\nDelete a team membership, by ID.\n\nGet a cat fact from catfact.ninja and return it as a string. Functions for Soundhound, Google, IBM Watson, or other APIs can be added to create the desired functionality into this bot.\n\nRespond to inbound webhook JSON HTTP POSTs from Webex Teams.\n\nDelete a membership, by ID.\n\nConvert a string (bytes, str or unicode) to unicode.\n\nConvert a string (bytes, str or unicode) to bytes.\n\nVerify that base_url specifies a protocol and network location.\n\nCheck to see if string is an validly-formatted web url."}
{"repo_name": "ibm-watson-iot/iot-python", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Parse a yaml configuration file into a Python dictionary suitable for passing to the device client constructor as the `options` parameter #\n\nInternal callback for device command messages, parses source device from topic string and passes the information on to the registered device command callback\n\nInternal callback for gateway command messages, parses source device from topic string and passes the information on to the registered device command callback\n\nInternal callback for gateway notification messages, parses source device from topic string and passes the information on to the registered device command callback\n\nGets the list of Historian connectors, they are used to configure the Watson IoT Platform to store IoT data in compatible services.\n\nCreate a connector for the organization in the Watson IoT Platform. The connector must reference the target service that the Watson IoT Platform will store the IoT data in.\n\nUpdates the connector with the specified uuid. if description is empty, the existing description will be removed.\n\nGets the list of services that the Watson IoT Platform can connect to. The list can include a mixture of services that are either bound or unbound.\n\nCreate a new external service. The service must include all of the details required to connect and authenticate to the external service in the credentials property.\n\nUpdates the service with the specified id. if description is empty, the existing description will be removed."}
{"repo_name": "rocky/python3-trepan", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "A simple event processor that prints out events.\n\nProgram counter.\n\nExecute a code object. When an exception occurs, self.showtraceback() is called to display a traceback. All exceptions are caught except SystemExit, which is reraised. A note about\n\nAdjust stack frame by pos positions. If absolute_pos then pos is an absolute number. Otherwise it is a relative number. A negative number indexes from the other end.\n\nParses arguments for the \"list\" command and returns the\n\nRead a line of input. EOFError will be raised on EOF.\n\nRun debugger on function\n\nRun debugger on string `expr' which will executed via the built-in Python\n\nRun each function in `hooks' with args\n\nPrint out a source location , e.g. the first line in line"}
{"repo_name": "ToucanToco/toucan-data-sdk", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Add new columns containing aggregations values on existing columns --- ###\n\nGet the top or flop N results based on a column value for each specified group columns --- ###\n\nConvert string column into datetime column --- ###\n\nConvert datetime column into string column --- ###\n\nConvert the format of a date --- ###\n\nConvert column's type into type --- ###\n\nThis function answers the\n\nThis function answers the\n\nThis function creates rank columns based on numeric values to be ranked. --- ###\n\nReturn a line for each bars of a waterfall chart, totals, groups, subgroups. Compute the variation and variation rate for each line. --- ###"}
{"repo_name": "zomux/deepy", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Optimize by SGD, AdaGrad, or AdaDelta.\n\nGeneral optimization function for Theano.\n\nCreate a optimizing function receives gradients.\n\nReturn updates in the training.\n\nGet parameters to be optimized.\n\nReturn updates from optimization.\n\nGet the learning function.\n\nGet baseline model.\n\nCompute first glimpse position using down-sampled image.\n\nAll codes that create parameters should be put into 'setup' function."}
{"repo_name": "authomatic/authomatic", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Creates |oauth2| request elements.\n\nDecode state and return param.\n\nRefreshes :class:`.Credentials` if it gives sense.\n\nWe need to override this method to fix Facebooks naming deviation.\n\nGoogle doesn't accept client ID and secret to be at the same time in request parameters and in the basic authorization header in the access token request.\n\nLogin handler, must accept both GET and POST to be able to use OpenID.\n\nReplaces all values that are single-item iterables with the value of its index 0.\n\nConverts list of tuples to dictionary with duplicate keys converted to lists.\n\nParses response body from JSON, XML or query string.\n\nCreates the value for ``Set-Cookie`` HTTP header."}
{"repo_name": "Nic30/hwt", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Gets value of bits between selected range from memory\n\nCast HArray signal or value to signal or value of type Bits\n\nconvert python slice to value of SLICE hdl type\n\nApply enclosure on list of statements (fill all unused code branches with assignments from value specified by enclosure)\n\nFind files by pattern in directory\n\nGenerate if tree for cases like (syntax shugar for large elifs)\n\nHdl convertible in operator, check if any of items in \"iterable\" equals \"sigOrVal\"\n\nGenerate for loop for static items\n\nConnect src (signals/interfaces/values) to all destinations\n\nRotate left"}
{"repo_name": "singularityhub/sregistry-cli", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "query a s3 endpoint for an image based on a string EXAMPLE\n\na \"show all\" search that doesn't require a query\n\nquery a Singularity registry for a list of images. If query is None, collections are listed. EXAMPLE\n\ncollection search will list all containers for a specific collection. We assume query is the name of a collection\n\nsearch across labels\n\nquery a GitLab artifacts folder for a list of images. If query is None, collections are listed.\n\na \"show all\" search that doesn't require a query the user is shown URLs to\n\nensure that the client name is included in a list of tags. This is important for matching builders to the correct client. We exit on fail.\n\nthe client will announce itself given that a command is not in a particular predefined list.\n\nThe user is required to have an application secrets file in his or her environment. The client exists with error if the variable isn't found."}
{"repo_name": "LLNL/scraper", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Retrieves the statistics from the given organization with the given credentials. Will not retreive data if file exists and force hasn't been set to True. This is to save GH API requests.\n\nRetrieves the number of members of the organization.\n\nRetrieves the number of teams of the organization.\n\nRetrieves info about the repos of the current organization.\n\nRetrieves the number of contributors to a repo in the organization. Also adds to unique contributor list.\n\nRetrieves the number of pull requests on a repo in the organization.\n\nRetrieves the number of closed issues.\n\nRetrieves the languages used in the repo and increments the respective counts of those languages. Only increments languages that have names. Anything else is not incremented (i.e. numbers).\n\nChecks to see if the given repo has a ReadMe. MD means it has a correct Readme recognized by GitHub.\n\nChecks to see if the given repo has a top level LICENSE file."}
{"repo_name": "assemblerflow/flowcraft", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Cleans the working directory of unwanted temporary files\n\nMerges the default adapters file in the trimmomatic adapters directory\n\nMain executor of the trimmomatic template.\n\nFunction that parse samtools depth file and creates 3 dictionaries that will be useful to make the outputs of this script, both the tabular file and the json file that may be imported by pATLAS\n\nFunction that handles the inputs required to parse depth files from bowtie and dumps a dict to a json file that can be imported into pATLAS.\n\nSets the main channel names based on the provide input and output channel suffixes. This is performed when connecting processes.\n\nWrapper to the jinja2 render method from a template file\n\nClass property that returns a populated template string This property allows the template of a particular process to be dynamically generated and returned when doing ``Process.template_str``.\n\nUpdates the forks attribute with the sink channel destination\n\nUpdates the directives attribute from a dictionary object. This will only update the directives for processes that have been defined in the subclass."}
{"repo_name": "urinieto/msaf", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Factorize s.t. CUR = data Updated Values -------------- .C : updated values for C. .U : updated values for U. .R : updated values for R.\n\nFactorize s.t. CUR = data Updated Values -------------- .C : updated values for C. .U : updated values for U. .R : updated values for R.\n\nFind data points on the convex hull of a supplied data set\n\nReturn data points that are most similar to basis vectors W\n\ncompute new W\n\nFactorize s.t. WH = data\n\ncompute new W\n\nFactorize s.t. WH = data\n\nMain process.\n\nMain process.for flat segmentation."}
{"repo_name": "neherlab/treetime", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "this function calculates the regression coefficients for a given vector containing the averages of tip and branch quantities.\n\ncalculate the covariance matrix of the tips assuming variance has accumulated along branches of the tree accoriding to the the provided\n\nInverse of the covariance matrix\n\nrecursion to calculate inverse covariance matrix\n\ncalculate the weighted sums of the tip and branch values and their second moments.\n\nThis function implements the propagation of the means, variance, and covariances along a branch. It operates both towards the root and tips.\n\ncalculate standard explained variance\n\nregress tip values against branch values\n\ndetermine the position on the tree that minimizes the bilinear product of the inverse covariance and the data vectors.\n\nPlot root-to-tip distance vs time as a basic time-tree diagnostic"}
{"repo_name": "Clinical-Genomics/scout", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Export gene panels to .bed like format. Specify any number of panels on the command line\n\nLoad a manually curated gene panel into scout\n\nLoad PanelApp panels into scout database If no panel_id load all PanelApp panels\n\nExport causative variants for a collaborator\n\nCreate the lines for an excel file with verified variants for an institute\n\nExport mitochondrial variants for a case to create a MT excel report\n\nUpdate a user in the database\n\nDisplay a list of SNV variants.\n\nDisplay a specific SNV variant.\n\nDisplay a list of STR variants."}
{"repo_name": "UCBerkeleySETI/blimpy", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Command line tool for plotting and viewing info on filterbank files\n\nPopulate Filterbank instance with data from HDF5 file\n\nSetup frequency axis\n\nSetup time axis.\n\nPopulate Filterbank instance with data from Filterbank file\n\nCompute LST for observation\n\nComputes the LSR in km/s uses the MJD, RA and DEC of observation to compute along with the telescope location. Requires pyslalib\n\nBlank DC bins in coarse channels.\n\nPrint header information\n\nreturns frequency array [f_start"}
{"repo_name": "RRZE-HPC/kerncraft", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Return potential locations of IACA installation.\n\nReturn (hopefully) valid installation of IACA.\n\nVery reduced regular expressions for describing a group of registers. Only groups in square bracktes and unions with pipes (|) are supported.\n\nReturn a LIKWID event string from an event tuple or keyword arguments. *event_tuple\n\nCompile list of minimal runs for given events.\n\nApply cache prediction to generate cache access behaviour.\n\nRun analysis.\n\nConvert performance (FLOP/s) to other units, such as It/s or cy/CL.\n\nReport analysis outcome in human readable form.\n\nRun complete analysis."}
{"repo_name": "gholt/swiftly", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Decrypts context.io_manager's stdin and sends that to context.io_manager's stdout. See :py:mod:`swiftly.cli.decrypt` for context usage information. See :py:class:`CLIDecrypt` for more information.\n\nConverts a client path into the operating system's path by replacing instances of '/' with os.path.sep.\n\nConverts an operating system path into a client path by replacing instances of os.path.sep with '/'.\n\nA context manager yielding a stdin-suitable file-like object based on the optional os_path and optionally skipping any configured sub-command.\n\nA context manager yielding a stdout-suitable file-like object based on the optional os_path and optionally skipping any configured sub-command.\n\nA context manager yielding a stderr-suitable file-like object based on the optional os_path and optionally skipping any configured sub-command.\n\nA context manager yielding a debug-output-suitable file-like object based on the optional os_path and optionally skipping any configured sub-command.\n\nDeletes the item (account, container, or object) at the path. See :py:mod:`swiftly.cli.delete` for context usage information. See :py:class:`CLIDelete` for more information.\n\nInstance method decorator to convert an optional file keyword argument into an actual value, whether it be a passed value, a value obtained from an io_manager, or sys.stdout.\n\nInstance method decorator to convert an optional file keyword argument into an actual value, whether it be a passed value, a value obtained from an io_manager, or sys.stderr."}
{"repo_name": "SmokinCaterpillar/pypet", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Generates a Cartesian product of the input parameter dictionary. For\n\nTakes a list of explored parameters and finds unique parameter combinations. If parameter ranges are hashable operates in O(N), otherwise O(N**2).\n\nHelper function to turn the simple logging kwargs into a `log_config`.\n\nDecorator to allow a simple logging configuration. This encompasses giving a `log_folder`, `logger_names` as well as `log_levels`.\n\nTries to make directories for a given `filename`. Ignores any error but notifies via stderr.\n\nAdds a logger with a given `name`. If no name is given, name is constructed as `type(self).__name__`.\n\nExtracts the wildcards and file replacements from the `trajectory`\n\nDisplays a progressbar\n\nSearches for parser settings that define filenames. If such settings are found, they are renamed according to the wildcard rules. Moreover, it is also tried to create the corresponding folders.\n\nTurns a ConfigParser into a StringIO stream."}
{"repo_name": "uw-it-aca/uw-restclients-canvas", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Return a list of all enrollments for the passed course_id.\n\nReturn a list of all enrollments for the passed course sis id.\n\nReturn a list of all enrollments for the passed section_id.\n\nReturn a list of all enrollments for the passed section sis id.\n\nReturn a list of enrollments for the passed user regid.\n\nEnroll a user into a course.\n\nList the roles for an account, for the passed Canvas account ID.\n\nList the roles for an account, for the passed account SIS ID.\n\nList all course roles available to an account, for the passed Canvas account ID, including course roles inherited from parent accounts.\n\nGet information about a single role, for the passed Canvas account ID."}
{"repo_name": "chrisrink10/basilisp", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Creates a new vector.\n\nCreates a new vector from members.\n\nEvaluate a file with the given name into a Python module AST node.\n\nEvaluate the forms in stdin into a Python module AST node.\n\nEvaluate the forms in a string into a Python module AST node.\n\nBootstrap the REPL with a few useful vars and returned the bootstrapped module so it's functions can be used by the REPL command.\n\nRun a Basilisp script or a line of code, if it is provided.\n\nDecorator function which can be used to make Python multi functions.\n\nSwap the methods atom to include method with key.\n\nAdd a new method to this function which will respond for key returned from the dispatch function."}
{"repo_name": "pmacosta/peng", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "r\"\"\" Include a Python source file in a docstring formatted in reStructuredText.\n\nGenerate combined independent variable vector. The combination is from two waveforms and the (possibly interpolated) dependent variable vectors of these two waveforms\n\nCreate new dependent variable vector.\n\nCreate new independent variable vector.\n\nVerify that two waveforms can be combined with various mathematical functions.\n\nDefine trace parameters.\n\nRun module tracing.\n\nr\"\"\" Echo terminal output. Print STDOUT resulting from a given Bash shell command (relative to the package :code:`pypkg` directory) formatted in reStructuredText\n\nPrint STDOUT resulting from a Bash shell command formatted in reStructuredText.\n\nTrace eng wave module exceptions."}
{"repo_name": "reingart/gui2py", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Recursively create and set the drop target for obj and childs\n\nEvent handler tool selection (just add to default handler)\n\nEvent handler for drag&drop functionality\n\ntrack default top level window for toolbox menu default action\n\nReturn a copy of the drop target (to avoid wx problems on rebuild)\n\nOpen the inspector windows for a given object\n\nOpen a shell\n\nTake a pythoncard background resource and convert to a gui2py window\n\nTake a pythoncard background resource and convert to a gui2py window\n\nConvert PythonCard font description to gui2py style"}
{"repo_name": "elliterate/capybara.py", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Builds and registers a :class:`Selector` object with the given name and configuration.\n\nDict[str, ExpressionFilter]:\n\nDict[str, NodeFilter]:\n\nAdds filters from a particular global :class:`FilterSet`.\n\nResolves this query relative to the given node.\n\nstr: A message describing the query failure.\n\nAsserts that the page has the given path. By default this will compare against the path+query portion of the full URL.\n\nAsserts that the page doesn't have the given path.\n\nChecks if the page has the given path.\n\nChecks if the page doesn't have the given path."}
{"repo_name": "lmjohns3/theanets", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Find the location of a dataset on disk, downloading if needed.\n\nLoad the MNIST digits dataset.\n\nLoad the CIFAR10 image dataset.\n\nCreate a plot of weights, visualized as \"bottom-level\" pixel arrays.\n\nCreate a plot of conv filters, visualized as pixel arrays.\n\nCreate a callable that generates samples from a dataset.\n\nEncode a text string by replacing characters with alphabet index.\n\nCreate a callable that returns a batch of training data.\n\nDraw a sequential sample of class labels from this network.\n\nAdd a convolutional weight array to this layer's parameters."}
{"repo_name": "dopefishh/pympi", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Read textgrid from stream.\n\nSort the tiers given the key.\n\nAdd an IntervalTier or a TextTier on the specified location.\n\nRemove a tier, when multiple tiers exist with that name only the first is removed.\n\nGives a tier, when multiple tiers exist with that name only the first is returned.\n\nWrite the object to a file.\n\nConvert the object to an pympi.Elan.Eaf object\n\nAdd a point to the TextTier\n\nAdd an interval to the IntervalTier.\n\nRemove an interval, if no interval is found nothing happens."}
{"repo_name": "its-rigs/Trolly", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Get information fot this organisation.\n\nGet all the boards for this organisation.\n\nGet all members attached to this organisation.\n\nUpdate this organisations information.\n\nRemove a member from the organisation.\n\nAdd a member to the board using the id. Membership type can be normal or admin.\n\nAdd a member to the board. Membership type can be normal or admin.\n\nGet information for this list.\n\nCreate a card for this list.\n\nGet all information for this Label."}
{"repo_name": "oscarbranson/latools", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Function for converting a dict to an array suitable for sklearn.\n\nFunction to format data for cluster fitting.\n\nFit KMeans clustering algorithm to data.\n\nFit MeanShift clustering algorithm to data.\n\nfit classifiers from large dataset.\n\nLabel new data with cluster identities.\n\nTranslate cluster identity back to original data size.\n\nSort clusters by the concentration of a particular analyte.\n\nReturn a datetime oject from a string, with optional time format.\n\nDetermines the most appropriate plotting unit for data."}
{"repo_name": "chrisjrn/registrasion", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Produces an appropriate _ProductsForm subclass for the given render type.\n\nCreates a StaffProductsForm that restricts the available products to those that are available to a user.\n\nAdds an error to the given product's field\n\nPrepares initial data for an instance of this form. product_quantities is a sequence of (product,quantity) tuples\n\nYields a sequence of (product, quantity) tuples from the cleaned form data.\n\nDecorator that stores the result of the stored function in the user's results cache until the batch completes. Keyword arguments are not yet supported.\n\nCreates a form for specifying fields from a model to display.\n\nAggregates the items that this user has purchased.\n\nAggregates the items that this user has purchased.\n\nSends an e-mail to the given address."}
{"repo_name": "ekmmetering/ekmmeters", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Send string to module level log\n\nRequired initialization call, wraps pyserial constructor.\n\nPassthrough for pyserial Serial.write().\n\nOptional polling loop control\n\nPoll for finished block or first byte ACK.\n\nUse the serial block definitions in V3 and V4 to create one field list.\n\nTranslate FieldType to portable SQL Type. Override if needful.\n\nReturn query portion below CREATE.\n\nReasonably portable SQL CREATE for defined fields.\n\nReasonably portable SQL INSERT for from combined read buffer."}
{"repo_name": "AkihikoITOH/capybara", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Updates the given defaults with values from the config files and the environ. Does a little special handling for certain types of options (lists).\n\nReturn a config dictionary with normalized keys regardless of whether the keys were specified in environment variables or in config files\n\nThe list from pypi is really a list of versions. We want a list of packages with the list of versions stored inline. This converts the list from pypi into one we can use.\n\nConvert the result back into the input type.\n\nParse a filename, URL, or file-like object into an HTML document tree.\n\nHelper function to submit a form.\n\nConvert all tags in an HTML tree to XHTML by moving them to the XHTML namespace.\n\nConvert all tags in an XHTML tree to HTML by removing their XHTML namespace.\n\nReturn an HTML string representation of the document.\n\nOpen the HTML document in a web browser, saving it to a temporary file to open it. Note that this does not delete the file after use. This is mainly meant for debugging."}
{"repo_name": "rwl/godot", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Sets for the _draw_ and _ldraw_ attributes for each of the graph sub-elements by processing the xdot format of the graph.\n\nParses the Xdot attributes of all graph components and adds the components to a new canvas.\n\nTrait initialiser.\n\nProperty getter.\n\nSets the connection string for all edges.\n\nMaintains each branch's list of available nodes in order that they may move themselves (InstanceEditor values).\n\nHandles the list of edges for any graph changing.\n\nTrait initialiser\n\nHandles the component being changed.\n\nTrait initialiser"}
{"repo_name": "bolt-project/bolt", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Create a spark bolt array from a local array.\n\nCreate a spark bolt array of ones.\n\nJoin two bolt arrays together, at least one of which is in spark.\n\nCheck that arguments are consistent with spark array construction. Conditions\n\nFormat target axes given an array shape\n\nWrap an existing numpy constructor in a parallelized construction\n\nApply a function across an axis. Array will be aligned so that the desired set of axes are in the keys, which may require a transpose/reshape.\n\nJoin this array with another array. Paramters --------- arry : ndarray or BoltArrayLocal Another array to concatenate with axis : int, optional, default=0 The axis along which arrays will be joined.\n\nConverts a BoltArrayLocal into a BoltArraySpark\n\nConverts a BoltArrayLocal into an RDD"}
{"repo_name": "jazzband/django-ddp", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Generate auth tokens tied to user and specified purpose. The hash expires at midnight on the minute of now + minutes_valid, such that when minutes_valid=1 you get *at least\n\nReturn specific time an auth_hash will expire.\n\nReturn login token info for given user.\n\nSerialize user as per Meteor accounts serialization.\n\nDe-serialize user profile fields into concrete model fields.\n\nUpdate user data.\n\nRetrieve the current user (or None) from the database.\n\nUpdate subs to send added/removed for collections with user_rel.\n\nConsistent fail so we don't provide attackers with valuable info.\n\nResolve and validate auth token, returns user object."}
{"repo_name": "neurodata/ndio", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Import a blosc array into a numpy array.\n\nExport a numpy array to a blosc array.\n\nTells you if you have an old version of ndio.\n\nConverts an array to its voxel list.\n\nConverts a voxel list to an ndarray.\n\nImport a png file into a numpy array.\n\nExport a numpy array to a png file.\n\nExport a numpy array to a set of png files, with each Z-index 2D array as its own 2D file.\n\nImport all files matching the filename base given with `png_filename_base`. Images are ordered by alphabetical order, which means that you *MUST\n\nGets the block-size for a given token at a given resolution."}
{"repo_name": "boundary/pulse-api-cli", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Handles the POST request sent by Boundary Url Action\n\nLoad the metrics file from the given path\n\n1) Get command line arguments 2) Read the JSON file 3) Parse into a dictionary 4) Create or update definitions using API call\n\nExtract required fields from an array\n\nApply the criteria to filter out on the metrics required\n\nExtracts the specific arguments of this CLI\n\nExtracts the specific arguments of this CLI\n\nMake a call to the meter via JSON RPC\n\nExtracts the specific arguments of this CLI\n\nExtracts the specific arguments of this CLI"}
{"repo_name": "treycucco/pyebnf", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "identifier = alpha_character | \"_\" . {alpha_character | \"_\" | digit} ;\n\nexpression_terminal = identifier | terminal | option_group | repetition_group | grouping_group | special_handling ;\n\noption_group = \"[\" , expression , \"]\" ;\n\nterminal = '\"' . (printable - '\"') + . '\"' | \"'\" . (printable - \"'\") + . \"'\" ;\n\noperator = \"|\" | \".\" | \",\" | \"-\";\n\nop_mult = \"*\" ;\n\nop_add = \"+\" ;\n\nEscape-aware text\n\nJoin an iterable by a delimiter, replacing instances of delimiter in items with escape + delimiter.\n\nGiven a list of newline positions, and an offset from the start of the source code that newline_positions was pulled from, return a 2-tuple of (line, char) coordinates."}
{"repo_name": "LionelAuroux/pyrser", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Return the list of all contained scope from global to local\n\nReturn the list of all contained scope from global to local\n\nThe current position of the cursor.\n\nThe index of the deepest character readed.\n\nPuts the cursor on the next character.\n\nSets cursor as beginning of next line.\n\nSets cursor as end of previous line.\n\nUsefull string to compute error message.\n\nIncrement the cursor to the next character.\n\nSave current position."}
{"repo_name": "inveniosoftware/invenio-migrator", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Default serializer for json.\n\nGet list of depositions (as iterator). This is redefined Deposition.get_depositions classmethod without order-by for better performance.\n\nGet deposits.\n\nDump the deposition object as dictionary.\n\nGet BibDocs for Invenio 1.\n\nGet BibDocs for Invenio 2.\n\nImport BibDocFile.\n\nDump all BibDoc metadata.\n\nGet bibdocs to check.\n\nCheck bibdocs."}
{"repo_name": "not-na/peng3d", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Similar to :py:attr:`pos` but for the size instead.\n\nDraws the background and the widget itself. Subclasses should use ``super()`` to call this method, or rendering may glitch out.\n\nSimple vector helper function returning the length of a vector. ``v`` may be any vector, with any number of dimensions\n\nNormalizes the given vector. The vector given may have any number of dimensions.\n\nHelper method ensuring per-entity bone data has been properly initialized. Should be called at the start of every method accessing per-entity data. ``data`` is the entity to check in dictionary form.\n\nSets the length of this bone on the given entity. ``data`` is the entity to modify in dictionary form. ``blength`` is the new length of the bone.\n\nSets the state required for this actor. Currently translates the matrix to the position of the actor.\n\nResets the state required for this actor to the default state. Currently resets the matrix to its previous translation.\n\nSets the state required for this vertex region. Currently binds and enables the texture of the material of the region.\n\nResets the state required for this actor to the default state. Currently only disables the target of the texture of the material, it may still be bound."}
{"repo_name": "trec-kba/streamcorpus-pipeline", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Try really really hard to get a Unicode copy of a string. First try :class:`BeautifulSoup.UnicodeDammit` to try to force to Unicode; if that fails, assume UTF-8 encoding, and ignore all errors.\n\nThis implements the MIME-type matching logic for deciding whether to run `make_clean_html`\n\nextract a lower-case, no-slashes domain name from a raw string that might be a URL\n\nreturns a list of strings created by splitting the domain on '.' and successively cutting off the left most portion\n\nRecord index records for a single document. Which indexes this creates depends on the parameters to the constructor. This records all of the requested indexes for a single document.\n\nGet strings that correspond to some hash. No string will correspond to :data:`DOCUMENT_HASH_KEY`; use :data:`DOCUMENT_HASH_KEY_REPLACEMENT` instead.\n\nGiven a spinn3r feed, produce a sequence of valid StreamItems. Because of goopy Python interactions, you probably need to call this and re-yield its results, as\n\nGiven a single spinn3r feed entry, produce a single StreamItem.\n\nRead (up to) 'n' bytes from the underlying file. If any bytes have been pushed in with _unread() those are returned first.\n\nRead exactly a varint out of the underlying file."}
{"repo_name": "xtuml/pyxtuml", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Parse argv for options and arguments, and start schema generation.\n\nget the C_C in which pe_pe is defined\n\nTransform textual OAL actions of an *instance\n\nTransform textual OAL actions in a ooaofooa *metamodel\n\nParse command line options and launch the prebuilder.\n\nFind a symbol in the symbol table by name, kind, or both.\n\nDetermine if a PE_PE is contained within a EP_PKG or a C_C.\n\nCheck if a PE_PE is globally defined, i.e. not inside a C_C\n\nGet the BridgePoint component (C_C) that defines the packeable element *pe_pe*.\n\nGet the base data type (S_DT) associated with a BridgePoint attribute."}
{"repo_name": "cloud9ers/gurumate", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Create a file with the specified name and write 'contents' (a sequence of strings without line terminators) to it.\n\nWrite `data` to `filename` (if not a dry run) after announcing it `what` is used in a log message to identify what is being written to the file.\n\nWrite the file list in 'self.filelist' (presumably as filled in by 'add_defaults()' and 'read_template()') to the manifest file named by 'self.manifest'.\n\nGiven a valid position in the text document, try to find the position of the matching bracket.\n\nConvenience method for selecting a character.\n\nUpdates the document formatting based on the new cursor position.\n\nBottleneck to fix up IronPython string exceptions\n\nRun tests in suite inside of suite fixtures.\n\nReturn the ancestry of the context (that is, all of the packages and modules containing the context), in order of descent with the outermost ancestor last. This method is a generator.\n\nThe complex case where there are tests that don't all share the same context. Groups tests into suites with common ancestors, according to the following (essentially tail-recursive)"}
{"repo_name": "tnkteja/myhelp", "repo_code": "def prepare_files(self, finder):\n        \"\"\"\"\"\"\n        from pip.index import Link\n\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            install = True\n            best_installed = False\n            not_found = None\n\n            \n            \n            \n\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall and not req_to_install.url:\n                            try:\n                                url = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            except DistributionNotFound as exc:\n                                not_found = exc\n                            else:\n                                \n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            \n                            \n                            if not (self.use_user_site\n                                    and not dist_in_usersite(\n                                        req_to_install.satisfied_by\n                                    )):\n                                req_to_install.conflicts_with = \\\n                                    req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.info(\n                            'Requirement already up-to-date: %s',\n                            req_to_install,\n                        )\n                    else:\n                        logger.info(\n                            'Requirement already satisfied (use --upgrade to '\n                            'upgrade): %s',\n                            req_to_install,\n                        )\n            if req_to_install.editable:\n                logger.info('Obtaining %s', req_to_install)\n            elif install:\n                if (req_to_install.url\n                        and req_to_install.url.lower().startswith('file:')):\n                    path = url_to_path(req_to_install.url)\n                    logger.info('Processing %s', display_path(path))\n                else:\n                    logger.info('Collecting %s', req_to_install)\n\n            with indent_log():\n                \n                \n                \n\n                is_wheel = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    \n                    \n                    \n                    \n\n                    \n                    \n                    location = req_to_install.build_location(\n                        self.build_dir,\n                    )\n                    unpack = True\n                    url = None\n\n                    \n                    \n                    \n                    if os.path.exists(os.path.join(location, 'setup.py')):\n                        raise PreviousBuildDirError(\n                            \"pip can't proceed with requirements '%s' due to a\"\n                            \" pre-existing build directory (%s). This is \"\n                            \"likely due to a previous installation that failed\"\n                            \". pip is being responsible and not assuming it \"\n                            \"can delete this. Please delete it and try again.\"\n                            % (req_to_install, location)\n                        )\n                    else:\n                        \n                        \n                        if req_to_install.url is None:\n                            if not_found:\n                                raise not_found\n                            url = finder.find_requirement(\n                                req_to_install,\n                                upgrade=self.upgrade,\n                            )\n                        else:\n                            \n                            \n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n\n                                if (\n                                    url.filename.endswith(wheel_ext)\n                                    and self.wheel_download_dir\n                                ):\n                                    \n                                    download_dir = self.wheel_download_dir\n                                    do_download = True\n                                else:\n                                    download_dir = self.download_dir\n                                    do_download = self.is_download\n                                unpack_url(\n                                    url, location, download_dir,\n                                    do_download, session=self.session,\n                                )\n                            except requests.HTTPError as exc:\n                                logger.critical(\n                                    'Could not install requirement %s because '\n                                    'of error %s',\n                                    req_to_install,\n                                    exc,\n                                )\n                                raise InstallationError(\n                                    'Could not install requirement %s because '\n                                    'of HTTP error %s for URL %s' %\n                                    (req_to_install, exc, url)\n                                )\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_wheel = url and url.filename.endswith(wheel_ext)\n                        if self.is_download:\n                            req_to_install.source_dir = location\n                            if not is_wheel:\n                                \n                                req_to_install.run_egg_info()\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.archive(self.download_dir)\n                        elif is_wheel:\n                            req_to_install.source_dir = location\n                            req_to_install.url = url.url\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            req_to_install.assert_source_matches_version()\n                        \n                        \n                        \n                        if not self.ignore_installed:\n                            req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                \n                                \n                                if not (self.use_user_site\n                                        and not dist_in_usersite(\n                                            req_to_install.satisfied_by)):\n                                    req_to_install.conflicts_with = \\\n                                        req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                logger.info(\n                                    'Requirement already satisfied (use '\n                                    '--upgrade to upgrade): %s',\n                                    req_to_install,\n                                )\n                                install = False\n\n                \n                \n                \n                if (req_to_install.extras):\n                    logger.debug(\n                        \"Installing extra requirements: %r\",\n                        ','.join(req_to_install.extras),\n                    )\n\n                if is_wheel:\n                    dist = list(\n                        pkg_resources.find_distributions(location)\n                    )[0]\n                else:  \n                    if req_to_install.satisfied_by:\n                        dist = req_to_install.satisfied_by\n                    else:\n                        dist = req_to_install.get_dist()\n                    \n                    if dist.has_metadata('dependency_links.txt'):\n                        finder.add_dependency_links(\n                            dist.get_metadata_lines('dependency_links.txt')\n                        )\n\n                if not self.ignore_dependencies:\n                    for subreq in dist.requires(\n                            req_to_install.extras):\n                        if self.has_requirement(\n                                subreq.project_name):\n                            \n                            continue\n                        subreq = InstallRequirement(\n                            str(subreq),\n                            req_to_install,\n                            isolated=self.isolated,\n                        )\n                        reqs.append(subreq)\n                        self.add_requirement(subreq)\n\n                if not self.has_requirement(req_to_install.name):\n                    \n                    self.add_requirement(req_to_install)\n\n                \n                if (self.is_download or\n                        req_to_install._temp_build_dir is not None):\n                    self.reqs_to_cleanup.append(req_to_install)\n\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n\ndef cleanup_files(self):\n        \"\"\"\"\"\"\n        logger.debug('Cleaning up...')\n        with indent_log():\n            for req in self.reqs_to_cleanup:\n                req.remove_temporary_source()\n\n            if self._pip_has_created_build_dir():\n                logger.debug('Removing temporary dir %s...', self.build_dir)\n                rmtree(self.build_dir)\n\ndef install(self, install_options, global_options=(), *args, **kwargs):\n        \"\"\"\"\"\"\n        to_install = [r for r in self.requirements.values()[::-1]\n                      if not r.satisfied_by]\n\n        \n        \n        \n        \n        \n        \n        distribute_req = pkg_resources.Requirement.parse(\"distribute>=0.7\")\n        for req in to_install:\n            if (req.name == 'distribute'\n                    and req.installed_version is not None\n                    and req.installed_version in distribute_req):\n                to_install.remove(req)\n                to_install.append(req)\n\n        if to_install:\n            logger.info(\n                'Installing collected packages: %s',\n                ', '.join([req.name for req in to_install]),\n            )\n\n        with indent_log():\n            for requirement in to_install:\n\n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                \n                if requirement.name == 'setuptools':\n                    try:\n                        \n                        \n                        \n                        distribute_requirement = \\\n                            pkg_resources.Requirement.parse(\"distribute<0.7\")\n                        existing_distribute = \\\n                            pkg_resources.get_distribution(\"distribute\")\n                        if existing_distribute in distribute_requirement:\n                            requirement.conflicts_with = existing_distribute\n                    except pkg_resources.DistributionNotFound:\n                        \n                        pass\n\n                if requirement.conflicts_with:\n                    logger.info(\n                        'Found existing installation: %s',\n                        requirement.conflicts_with,\n                    )\n                    with indent_log():\n                        requirement.uninstall(auto_confirm=True)\n                try:\n                    requirement.install(\n                        install_options,\n                        global_options,\n                        *args,\n                        **kwargs\n                    )\n                except:\n                    \n                    if (requirement.conflicts_with\n                            and not requirement.install_succeeded):\n                        requirement.rollback_uninstall()\n                    raise\n                else:\n                    if (requirement.conflicts_with\n                            and requirement.install_succeeded):\n                        requirement.commit_uninstall()\n                requirement.remove_temporary_source()\n\n        self.successfully_installed = to_install\n\ndef _collapse_leading_ws(header, txt):\n    \"\"\"\"\"\"\n    if header.lower() == 'description':  \n        return '\\n'.join([x[8:] if x.startswith(' ' * 8) else x\n                          for x in txt.strip().splitlines()])\n    else:\n        return ' '.join([x.strip() for x in txt.splitlines()])\n\ndef get_refs(self, location):\n        \"\"\"\"\"\"\n        output = call_subprocess([self.cmd, 'show-ref'],\n                                 show_stdout=False, cwd=location)\n        rv = {}\n        for line in output.strip().splitlines():\n            commit, ref = line.split(' ', 1)\n            ref = ref.strip()\n            ref_name = None\n            if ref.startswith('refs/remotes/'):\n                ref_name = ref[len('refs/remotes/'):]\n            elif ref.startswith('refs/heads/'):\n                ref_name = ref[len('refs/heads/'):]\n            elif ref.startswith('refs/tags/'):\n                ref_name = ref[len('refs/tags/'):]\n            if ref_name is not None:\n                rv[ref_name] = commit.strip()\n        return rv\n\ndef find_command(cmd, paths=None, pathext=None):\n    \"\"\"\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '').split(os.pathsep)\n    if isinstance(paths, six.string_types):\n        paths = [paths]\n    \n    if pathext is None:\n        pathext = get_pathext()\n    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]\n    \n    if os.path.splitext(cmd)[1].lower() in pathext:\n        pathext = ['']\n    \n    for path in paths:\n        \n        cmd_path = os.path.join(path, cmd)\n        for ext in pathext:\n            \n            cmd_path_ext = cmd_path + ext\n            if os.path.isfile(cmd_path_ext):\n                return cmd_path_ext\n        if os.path.isfile(cmd_path):\n            return cmd_path\n    raise BadCommand('Cannot find command %r' % cmd)\n\ndef normalize_path(path):\n    \"\"\"\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))\n\ndef run():\n    \"\"\"\"\"\"\n    \n    config_option_help=\"'show' - displays configured options, 'set [section] [name] [value]' - sets config under a section,'set [name] [value]' - sets configuration globally\" \n\n    parser = OptionParser()\n    \n    parser.add_option(\"-a\", \"--add\", action=\"store\", type=\"string\", dest=\"addfile\", help=\"adds a notes\")\n    parser.add_option(\"-c\", \"--config\", action=\"store\", type=\"string\", dest=\"config\", help=config_option_help)\n    parser.add_option(\"-e\", \"--edit\", action=\"store\", type=\"string\", dest=\"editfile\", help=\"edits a notes\")\n    parser.add_option(\"-o\", \"--open\", action=\"store\", type=\"string\", dest=\"openfile\", help=\"opens a notes\")\n    parser.add_option(\"-r\", \"--remove\", action=\"store\", type=\"string\", dest=\"remove\", help=\"removes a notes\")\n\n    options, args = parser.parse_args()\n    \n    if options.config:\n        if options.config == \"show\":\n            config_option_list=''\n            config_sections = config.sections()\n            for section in config_sections:\n                config_option_list=config_option_list+section+\"\\n\"\n                section_items =config.items(section)\n                for item in section_items:\n                    config_option_list=config_option_list+\"    \"+item[0]+\"    \"+item[1]+\"\\n\" \n            print config_option_list\n            quit()\n        \n    def add_notes(note_name,existing_tags):\n       call([editor,environ[\"HOME\"] + \"/.mypy/myhelp/notes/\"+note_name+\".note\"])\n       definedtags = raw_input(\"Define Tags (separated by spaces): \").split(\" \")\n       definedtags.append(note_name)\n       print definedtags\n       print existing_tags\n       definedtags=list(set(definedtags)-set(existing_tags))\n       print definedtags\n       if len(definedtags)>0:\n           modify_tags_xml(note_name,definedtags,files,rootfiles,tags,roottags,tree,TAGS_XML_DIR)  \n\n    def get_tags_from_file(note_name):\n        fil = get_file_from_files(note_name)       \n        filetags = fil.iter('tag')\n        filetaglist=[]\n        for tag in filetags:\n            filetaglist.append(tag.text)\n        return filetaglist\n\n    if options.addfile:\n       existing_tags=[]\n       if isFile(options.addfile,files):\n           existing_tags=get_tags_from_file(options.addfile)\n           raw_input(\"Note exists with tags - \"+\" \".join(existing_tags)+\"\\nDo you want to edit the notes ? [Press enter to continue]\\n\") \n       add_notes(options.addfile,existing_tags)\n       quit()\n\n    if options.editfile:\n        if isFile(options.editfile,files):\n            add_notes(note_name,[])\n        else:\n           raw_input(\"Note doesn't exist.\\nDo you want add note ? [Press enter to continue]\")     \n           add_notes(note_name)\n        \n    if options.remove:\n        pass\n    \n    if len(args) != 1:\n        print \"Please use a search term\\n example : myhelp <some tag word> \"\n        quit()\n    _key_File = \"Note\"\n    _key_Results = \"    Results                                     \"\n    table={_key_Results:[]}\n    for tag in tags:\n        if tag.attrib[\"value\"] == args[0]:\n            fileelements = tag.iter(\"file\")\n            for fileelement in fileelements:\n                f = open(\n                    environ[\"HOME\"] + \"/.mypy/myhelp/notes/\" + fileelement.text+\".note\", \"r\")\n\t\ttable[_key_Results].append(f.read()+\"\\r\\n\\tfile: ~/.mypy/myhelp/notes/\"+fileelement.text+\".note\")\n                f.close()\n\n    print tabulate(table,headers=[],tablefmt=\"rst\")\n\ndef _find_url_name(self, index_url, url_name, req):\n        \"\"\"\"\"\"\n        if not index_url.url.endswith('/'):\n            \n            \n            index_url.url += '/'\n        page = self._get_page(index_url, req)\n        if page is None:\n            logger.critical('Cannot fetch index base URL %s', index_url)\n            return\n        norm_name = normalize_name(req.url_name)\n        for link in page.links:\n            base = posixpath.basename(link.path.rstrip('/'))\n            if norm_name == normalize_name(base):\n                logger.debug(\n                    'Real name of requirement %s is %s', url_name, base,\n                )\n                return base\n        return None\n\ndef _link_package_versions(self, link, search_name):\n        \"\"\"\"\"\"\n        platform = get_platform()\n\n        version = None\n        if link.egg_fragment:\n            egg_info = link.egg_fragment\n        else:\n            egg_info, ext = link.splitext()\n            if not ext:\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; not a file', link)\n                    self.logged_links.add(link)\n                return\n            if egg_info.endswith('.tar'):\n                \n                egg_info = egg_info[:-4]\n                ext = '.tar' + ext\n            if ext not in self._known_extensions():\n                if link not in self.logged_links:\n                    logger.debug(\n                        'Skipping link %s; unknown archive format: %s',\n                        link,\n                        ext,\n                    )\n                    self.logged_links.add(link)\n                return\n            if \"macosx10\" in link.path and ext == '.zip':\n                if link not in self.logged_links:\n                    logger.debug('Skipping link %s; macosx10 one', link)\n                    self.logged_links.add(link)\n                return\n            if ext == wheel_ext:\n                try:\n                    wheel = Wheel(link.filename)\n                except InvalidWheelFilename:\n                    logger.debug(\n                        'Skipping %s because the wheel filename is invalid',\n                        link\n                    )\n                    return\n                if (pkg_resources.safe_name(wheel.name).lower()\n                        != pkg_resources.safe_name(search_name).lower()):\n                    logger.debug(\n                        'Skipping link %s; wrong project name (not %s)',\n                        link,\n                        search_name,\n                    )\n                    return\n                if not wheel.supported():\n                    logger.debug(\n                        'Skipping %s because it is not compatible with this '\n                        'Python',\n                        link,\n                    )\n                    return\n                \n                \n                \n                \n                \n                \n                comes_from = getattr(link, \"comes_from\", None)\n                if (\n                        (\n                            not platform.startswith('win')\n                            and not platform.startswith('macosx')\n                            and not platform == 'cli'\n                        )\n                        and comes_from is not None\n                        and urllib_parse.urlparse(\n                            comes_from.url\n                        ).netloc.endswith(PyPI.netloc)):\n                    if not wheel.supported(tags=supported_tags_noarch):\n                        logger.debug(\n                            \"Skipping %s because it is a pypi-hosted binary \"\n                            \"Wheel on an unsupported platform\",\n                            link,\n                        )\n                        return\n                version = wheel.version\n\n        if not version:\n            version = self._egg_info_matches(egg_info, search_name, link)\n        if version is None:\n            logger.debug(\n                'Skipping link %s; wrong project name (not %s)',\n                link,\n                search_name,\n            )\n            return\n\n        if (link.internal is not None\n                and not link.internal\n                and not normalize_name(search_name).lower()\n                in self.allow_external\n                and not self.allow_all_external):\n            \n            \n            logger.debug(\"Skipping %s because it is externally hosted.\", link)\n            self.need_warn_external = True\n            return\n\n        if (link.verifiable is not None\n                and not link.verifiable\n                and not (normalize_name(search_name).lower()\n                         in self.allow_unverified)):\n            \n            \n            \n            logger.debug(\n                \"Skipping %s because it is an insecure and unverifiable file.\",\n                link,\n            )\n            self.need_warn_unverified = True\n            return\n\n        match = self._py_version_re.search(version)\n        if match:\n            version = version[:match.start()]\n            py_version = match.group(1)\n            if py_version != sys.version[:3]:\n                logger.debug(\n                    'Skipping %s because Python version is incorrect', link\n                )\n                return\n        logger.debug('Found link %s, version: %s', link, version)\n\n        return InstallationCandidate(search_name, version, link)", "repo_summary": "Prepare process. Create temp directories, download and/or unpack files.\n\nClean up files, remove builds.\n\nInstall everything in this set (after having downloaded and unpacked the packages)\n\n``Description`` header must preserve newlines; all others need not\n\nReturn map of named refs (branches or tags) to commit hashes.\n\nSearches the PATH for the given command and returns its path\n\nConvert a path to its canonical, case-normalized, absolute version.\n\nMain method where all logic is defined\n\nFinds the true URL name of a package, when the given name isn't quite correct. This is usually used to implement case-insensitivity.\n\nReturn an iterable of triples (pkg_resources_version_key, link, python_version) that can be extracted from the given link. Meant to be overridden by subclasses, not called by clients."}
